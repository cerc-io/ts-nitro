/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace INitroTypes {
  export type FixedPartStruct = {
    participants: string[];
    channelNonce: BigNumberish;
    appDefinition: string;
    challengeDuration: BigNumberish;
  };

  export type FixedPartStructOutput = [string[], BigNumber, string, number] & {
    participants: string[];
    channelNonce: BigNumber;
    appDefinition: string;
    challengeDuration: number;
  };

  export type VariablePartStruct = {
    outcome: ExitFormat.SingleAssetExitStruct[];
    appData: BytesLike;
    turnNum: BigNumberish;
    isFinal: boolean;
  };

  export type VariablePartStructOutput = [
    ExitFormat.SingleAssetExitStructOutput[],
    string,
    number,
    boolean
  ] & {
    outcome: ExitFormat.SingleAssetExitStructOutput[];
    appData: string;
    turnNum: number;
    isFinal: boolean;
  };

  export type RecoveredVariablePartStruct = {
    variablePart: INitroTypes.VariablePartStruct;
    signedBy: BigNumberish;
  };

  export type RecoveredVariablePartStructOutput = [
    INitroTypes.VariablePartStructOutput,
    BigNumber
  ] & {
    variablePart: INitroTypes.VariablePartStructOutput;
    signedBy: BigNumber;
  };
}

export declare namespace ExitFormat {
  export type AssetMetadataStruct = {
    assetType: BigNumberish;
    metadata: BytesLike;
  };

  export type AssetMetadataStructOutput = [number, string] & {
    assetType: number;
    metadata: string;
  };

  export type AllocationStruct = {
    destination: BytesLike;
    amount: BigNumberish;
    allocationType: BigNumberish;
    metadata: BytesLike;
  };

  export type AllocationStructOutput = [string, BigNumber, number, string] & {
    destination: string;
    amount: BigNumber;
    allocationType: number;
    metadata: string;
  };

  export type SingleAssetExitStruct = {
    asset: string;
    assetMetadata: ExitFormat.AssetMetadataStruct;
    allocations: ExitFormat.AllocationStruct[];
  };

  export type SingleAssetExitStructOutput = [
    string,
    ExitFormat.AssetMetadataStructOutput,
    ExitFormat.AllocationStructOutput[]
  ] & {
    asset: string;
    assetMetadata: ExitFormat.AssetMetadataStructOutput;
    allocations: ExitFormat.AllocationStructOutput[];
  };
}

export interface ConsensusAppInterface extends utils.Interface {
  functions: {
    "stateIsSupported((address[],uint64,address,uint48),(((address,(uint8,bytes),(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool),uint256)[],(((address,(uint8,bytes),(bytes32,uint256,uint8,bytes)[])[],bytes,uint48,bool),uint256))": FunctionFragment;
  };

  getFunction(nameOrSignatureOrTopic: "stateIsSupported"): FunctionFragment;

  encodeFunctionData(
    functionFragment: "stateIsSupported",
    values: [
      INitroTypes.FixedPartStruct,
      INitroTypes.RecoveredVariablePartStruct[],
      INitroTypes.RecoveredVariablePartStruct
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "stateIsSupported",
    data: BytesLike
  ): Result;

  events: {};
}

export interface ConsensusApp extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ConsensusAppInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    stateIsSupported(
      fixedPart: INitroTypes.FixedPartStruct,
      proof: INitroTypes.RecoveredVariablePartStruct[],
      candidate: INitroTypes.RecoveredVariablePartStruct,
      overrides?: CallOverrides
    ): Promise<[boolean, string]>;
  };

  stateIsSupported(
    fixedPart: INitroTypes.FixedPartStruct,
    proof: INitroTypes.RecoveredVariablePartStruct[],
    candidate: INitroTypes.RecoveredVariablePartStruct,
    overrides?: CallOverrides
  ): Promise<[boolean, string]>;

  callStatic: {
    stateIsSupported(
      fixedPart: INitroTypes.FixedPartStruct,
      proof: INitroTypes.RecoveredVariablePartStruct[],
      candidate: INitroTypes.RecoveredVariablePartStruct,
      overrides?: CallOverrides
    ): Promise<[boolean, string]>;
  };

  filters: {};

  estimateGas: {
    stateIsSupported(
      fixedPart: INitroTypes.FixedPartStruct,
      proof: INitroTypes.RecoveredVariablePartStruct[],
      candidate: INitroTypes.RecoveredVariablePartStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    stateIsSupported(
      fixedPart: INitroTypes.FixedPartStruct,
      proof: INitroTypes.RecoveredVariablePartStruct[],
      candidate: INitroTypes.RecoveredVariablePartStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
