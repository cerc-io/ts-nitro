import { ethers } from 'ethers';
import _ from 'lodash';
import { Buffer } from 'buffer';

import {
  FieldDescription, NitroSigner, bytes2Hex, hex2Bytes,
} from '@cerc-io/nitro-util';

// Signature is an ECDSA signature
export type Signature = {
  r: Buffer | null;
  s: Buffer | null;
  v: number;
};

export const signatureJsonEncodingMap: Record<string, FieldDescription> = {
  r: { type: 'buffer' },
  s: { type: 'buffer' },
  v: { type: 'number' },
};

// computeEthereumSignedMessageDigest accepts an arbitrary message, prepends a known message,
// and hashes the result using keccak256. The known message added to the input before hashing is
// "\x19Ethereum Signed Message:\n" + len(message).
const computeEthereumSignedMessageDigest = (message: Buffer): Buffer => {
  const prefix = `\x19Ethereum Signed Message:\n${message.length}`;
  const messageBytes = ethers.utils.concat([
    Buffer.from(prefix),
    message,
  ]);
  return Buffer.from(ethers.utils.keccak256(messageBytes));
};

// SignEthereumMessage accepts an arbitrary message, prepends a known message,
// hashes the result using keccak256 and calculates the secp256k1 signature
// of the hash using the provided secret key. The known message added to the input before hashing is
// "\x19Ethereum Signed Message:\n" + len(message).
// See https://github.com/ethereum/go-ethereum/pull/2940 and EIPs 191, 721.
export const signEthereumMessage = async (message: Buffer, signer: NitroSigner): Promise<Signature> => {
  const sig = await signer.signMessage(message.toString());

  /* eslint-disable @typescript-eslint/no-use-before-define */
  return getSignatureFromEthersSignature(sig);
};

// RecoverEthereumMessageSigner accepts a message (bytestring) and signature generated by SignEthereumMessage.
// It reconstructs the appropriate digest and recovers an address via secp256k1 public key recovery
export const recoverEthereumMessageSigner = (message: Buffer, signature: Signature): string => {
  // This step is necessary to remain compatible with the ecrecover precompile
  const sig = _.cloneDeep(signature);
  if (sig.v >= 27) {
    sig.v -= 27;
  }

  const digest = computeEthereumSignedMessageDigest(message);

  return ethers.utils.recoverAddress(
    digest.toString(),
    {
      r: `0x${bytes2Hex(sig.r ?? Buffer.alloc(0))}`,
      s: `0x${bytes2Hex(sig.s ?? Buffer.alloc(0))}`,
      v: sig.v,
    },
  );
};

export const equal = (s1: Signature, s2 :Signature): boolean => {
  return _.isEqual(s1.r, s2.r)
  && _.isEqual(s1.s, s2.s)
  && s1.v === s2.v;
};

// Custom function to get Signature instance from an ethers Signature
export const getSignatureFromEthersSignature = (sig: ethers.Signature): Signature => {
  // This step is necessary to remain compatible with the ecrecover precompile
  return {
    r: hex2Bytes(sig.r),
    s: hex2Bytes(sig.s),
    v: sig.v < 27 ? sig.v + 27 : sig.v,
  };
};
