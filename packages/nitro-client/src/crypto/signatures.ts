import { ethers } from 'ethers';
import _ from 'lodash';

import { FieldDescription, bytes2Hex, hex2Bytes } from '@cerc-io/nitro-util';
// TODO: Use forked @statechannels/nitro-protocol
import { signData as utilSignData } from '@statechannels/nitro-protocol/dist/src/signatures';

// Signature is an ECDSA signature
export type Signature = {
  r: Buffer;
  s: Buffer;
  v: number;
};

export const signatureJsonEncodingMap: Record<string, FieldDescription> = {
  r: { type: 'buffer' },
  s: { type: 'buffer' },
  v: { type: 'number' },
};

// computeEthereumSignedMessageDigest accepts an arbitrary message, prepends a known message,
// and hashes the result using keccak256. The known message added to the input before hashing is
// "\x19Ethereum Signed Message:\n" + len(message).
const computeEthereumSignedMessageDigest = (message: Buffer): Buffer => {
  const prefix = `\x19Ethereum Signed Message:\n${message.length}`;
  const messageBytes = ethers.utils.concat([
    Buffer.from(prefix),
    message,
  ]);
  return Buffer.from(ethers.utils.keccak256(messageBytes));
};

// SignEthereumMessage accepts an arbitrary message, prepends a known message,
// hashes the result using keccak256 and calculates the secp256k1 signature
// of the hash using the provided secret key. The known message added to the input before hashing is
// "\x19Ethereum Signed Message:\n" + len(message).
// See https://github.com/ethereum/go-ethereum/pull/2940 and EIPs 191, 721.
export const signEthereumMessage = (message: Buffer, secretKey: Buffer): Signature => {
  const sig = utilSignData(message.toString(), `0x${bytes2Hex(secretKey)}`);

  // This step is necessary to remain compatible with the ecrecover precompile
  if (sig.v < 27) {
    sig.v += 27;
  }

  return {
    r: hex2Bytes(sig.r),
    s: hex2Bytes(sig.s),
    v: sig.v,
  };
};

// RecoverEthereumMessageSigner accepts a message (bytestring) and signature generated by SignEthereumMessage.
// It reconstructs the appropriate digest and recovers an address via secp256k1 public key recovery
export const recoverEthereumMessageSigner = (message: Buffer, signature: Signature): string => {
  // This step is necessary to remain compatible with the ecrecover precompile
  const sig = _.cloneDeep(signature);
  if (sig.v >= 27) {
    sig.v -= 27;
  }

  const digest = computeEthereumSignedMessageDigest(message);

  return ethers.utils.recoverAddress(
    digest.toString(),
    {
      r: `0x${bytes2Hex(sig.r)}`,
      s: `0x${bytes2Hex(sig.s)}`,
      v: sig.v,
    },
  );
};

export const equal = (s1: Signature, s2 :Signature): boolean => {
  return s1.r.compare(s2.r) === 0
  && s1.s.compare(s2.s) === 0
  && s1.v === s2.v;
};
